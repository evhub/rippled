from __future__ import absolute_import, division, print_function, unicode_literals

import ntpath
import os
import sys
import textwrap

DEFAULT_CXX_FLAGS = ['-std=c++11', '-frtti', '-g']

ENVIRONMENT_VARIABLES = [
  'CC', 'CXX', 'CFLAGS', 'CCFLAGS', 'CPPFLAGS',
  'CXXFLAGS', 'LIBPATH', 'LINKFLAGS', 'LIBS']

LIBS_PREFIX = '// LIBS:'
MODS_PREFIX = '// MODULES:'

VARIANT_DIRECTORIES = {
    'beast': ('bin', 'beast'),
    'modules': ('bin', 'modules'),
}

MAIN_PROGRAM_FILE = 'beast/unit_test/tests/main.cpp'

NAME_VALUE_PAIR_FORMAT = '%s \033[94m%s\033[0m'
COMMAND_LINE_FORMAT = '           \033[94m%s\033[0m'
EMPTY_NAME = '          '

def print_build_vars(env, var):
    """Pretty-print values as a build configuration."""
    val = env.get(var, '')

    if val:
        name = '%s' % var.rjust(10)

        wrapper = textwrap.TextWrapper()
        wrapper.break_long_words = False
        wrapper.break_on_hyphens = False
        wrapper.width = 69

        if type(val) is str:
            lines = wrapper.wrap(val)
        else:
            lines = wrapper.wrap(' '.join(str(x) for x in val))

        for line in lines:
            print(NAME_VALUE_PAIR_FORMAT % (name, line))
            name = EMPTY_NAME

def print_build_config(env):
    config_vars = ENVIRONMENT_VARIABLES
    sys.stdout.write('\nConfiguration:\n')
    for var in config_vars:
        print_build_vars(env,var)
    print()

def print_cmd_line(s, target, src, env):
    target = (''.join([str(x) for x in target]))
    # source = (''.join([str(x) for x in src]))
    print(COMMAND_LINE_FORMAT % target)


def get_libs(path):
    """Returns the list of libraries needed by the test source file. This is
       accomplished by scanning the source file for a special comment line
       with this format, which must match exactly:

       // LIBS: <name>...

       path = path to source file"""

    prefix = LIBS_PREFIX
    with open(path, 'rb') as f:
        for line in f:
            line = line.strip()
            if line.startswith(prefix):
                items = line.split(prefix, 1)[1].strip()
                return [x.strip() for x in items.split(' ')]

def get_mods(path):
    """Returns the list of source modules needed by the test source file.

     // MODULES: <module>...

     path = path to source file."""

    prefix = MODS_PREFIX
    with open(path, 'rb') as f:
        for line in f:
            line = line.strip()
            if line.startswith(prefix):
                items = line.split(prefix, 1)[1].strip()
                items = [os.path.normpath(os.path.join(
                    os.path.dirname(path), x.strip())) for
                        x in items.split(' ')]
                return items

def build_test(env, path):
    """Build a stand alone executable that runs
       all the test suites in one source file."""
    libs = get_libs(path)
    mods = get_mods(path)
    bin = os.path.basename(os.path.splitext(path)[0])
    bin = os.path.join('bin', bin)
    srcs = [MAIN_PROGRAM_FILE, path] + (mods or [])

    # All paths get normalized here, so we can use posix
    # forward slashes for everything including on Windows
    srcs = [os.path.normpath(os.path.join('bin', x)) for x in srcs]
    objs = [os.path.splitext(x)[0] + '.o' for x in srcs]
    env_ = env
    if libs:
        env_.Append(LIBS=libs)
    env_.Program(bin, srcs)

#-------------------------------------------------------------------------------

def main():
    env = Environment()

    env['PRINT_CMD_LINE_FUNC'] = print_cmd_line

    for name, path in VARIANT_DIRECTORIES.items():
        env.VariantDir(os.path.join(*path), name, duplicate=0)

    # Copy important os environment variables into env
    replacements = {}
    for variable in ENVIRONMENT_VARIABLES:
        value = os.environ.get(variable)
        if value:
            replacements[variable] = value
    env.Replace(**replacements)

    # Set up boost variables
    home = os.environ.get('BOOST_HOME', None)
    if home is not None:
        env.Prepend(CPPPATH=home)
        env.Append(LIBPATH=os.path.join(home, 'stage', 'lib'))

    # Set up flags
    if not env.get('CXXFLAGS'):
      env['CXXFLAGS'] = DEFAULT_CXX_FLAGS

    for root, dirs, files in os.walk('.'):
        for path in files:
            path = os.path.join(root,path)
            if (path.endswith('.test.cpp')):
                build_test(env,path)

    print_build_config(env)

main()
