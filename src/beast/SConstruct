from __future__ import absolute_import, division, print_function, unicode_literals

import curses
import ntpath
import os
import sys
import textwrap

DEFAULT_CXX_FLAGS = ['-std=c++11', '-frtti', '-g']

ENVIRONMENT_VARIABLES = [
  'CC', 'CXX', 'CFLAGS', 'CCFLAGS', 'CPPFLAGS',
  'CXXFLAGS', 'LIBPATH', 'LINKFLAGS', 'LIBS']

LIBS_PREFIX = '// LIBS:'
MODS_PREFIX = '// MODULES:'

VARIANT_DIRECTORIES = {
    'beast': ('bin', 'beast'),
    'modules': ('bin', 'modules'),
}

MAIN_PROGRAM_FILE = 'beast/unit_test/tests/main.cpp'
FIELD_WIDTH = 10

NAME_VALUE_PAIR_FORMAT = '%s \033[94m%s\033[0m'
COMMAND_LINE_FORMAT = '           \033[94m%s\033[0m'
EMPTY_NAME = ' ' * FIELD_WIDTH

def graphics(text, *modes):
  modes = ';'.join(str(m) for m in modes)
  return '\033[%sm%s\033[0m' % (modes, text)

def blue(text):
  return graphics(text, 94)

TEXT_WRAPPER = textwrap.TextWrapper(
    break_long_words=False,
    break_on_hyphens=False,
    width=69,
)

DISPLAY_EMPTY_ENVS = True
BOOST_HOME = 'BOOST_HOME'

def is_string(s):
  return isinstance(s, (str, unicode))

def get_boost_path():
    try:
       return os.environ[BOOST_HOME]
    except KeyError:
      raise KeyError('%s environment variable is not set.' % BOOST_HOME)

def join_items(items, joiner=''):
    return joiner.join(str(i) for i in items or ())

def print_build_vars(env, name, value):
    """Pretty-print values as a build configuration."""
    name = '%s' % name.rjust(FIELD_WIDTH)

    if not is_string(value):
        value = join_items(value, ' ')

    for line in TEXT_WRAPPER.wrap(value):
        print(' '.join([name, blue(line)]))
        name = EMPTY_NAME

def print_build_config(env):
    print('\nConfiguration:')
    for variable in ENVIRONMENT_VARIABLES:
        value = env.get(variable)
        if value or DISPLAY_EMPTY_ENVS:
           print_build_vars(env, variable, value)
    print()

def print_cmd_line(s, target, source, env):
    print(COMMAND_LINE_FORMAT % join_items(target))

def first_line_starting_with(filename, prefix):
  with open(filename, 'r') as contents:
    for line in contents:
      line = line.strip()
      if line.startswith(prefix):
        return line[len(prefix):].split()
  return []

def get_libs(path):
    """Returns the list of libraries needed by the test source file. This is
       accomplished by scanning the source file for a special comment line
       with this format, which must match exactly:

       // LIBS: <name>...

       path = path to source file"""

    return first_line_starting_with(path, LIBS_PREFIX)

def get_source_modules(path):
    """Returns the list of source modules needed by the test source file.

     // MODULES: <module>...

     path = path to source file."""

    items = first_line_starting_with(path, MODS_PREFIX)
    parent = os.path.dirname(os.path.normpath(path))
    return [os.path.join(parent, i) for i in items]


def build_test(env, path):
    """Build a stand alone executable that runs
       all the test suites in one source file."""
    libs = get_libs(path)
    source_modules = get_source_modules(path)
    bin = os.path.basename(os.path.splitext(path)[0])
    bin = os.path.join('bin', bin)
    srcs = [MAIN_PROGRAM_FILE, path] + (source_modules or [])

    # All paths get normalized here, so we can use posix
    # forward slashes for everything including on Windows
    srcs = [os.path.normpath(os.path.join('bin', x)) for x in srcs]
    objs = [os.path.splitext(x)[0] + '.o' for x in srcs]
    env_ = env
    if libs:
        env_.Append(LIBS=libs)
    env_.Program(bin, srcs)

#-------------------------------------------------------------------------------

def main():
    env = Environment()

    env['PRINT_CMD_LINE_FUNC'] = print_cmd_line

    for name, path in VARIANT_DIRECTORIES.items():
        env.VariantDir(os.path.join(*path), name, duplicate=0)

    # Copy important os environment variables into env
    replacements = {}
    for variable in ENVIRONMENT_VARIABLES:
        value = os.environ.get(variable)
        if value:
            replacements[variable] = value
    env.Replace(**replacements)

    # Set up the boost path.
    boost_path = get_boost_path()
    if boost_path:
      env.Prepend(CPPPATH=boost_path)
    env.Append(LIBPATH=os.path.join(boost_path, 'stage', 'lib'))

    for root, dirs, files in os.walk('.'):
        for path in files:
            path = os.path.join(root,path)
            if (path.endswith('.test.cpp')):
                build_test(env,path)

    print_build_config(env)

main()
